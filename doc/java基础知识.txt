1，内部类：
	成员内部类 ：成员内部类可以无条件的访问外部类的成员属性和成员方法（包括 private 和 static 类型的成员)，
	             这是因为在内部类中，隐式地持有了外部类的引用
				 
				 成员内部类不能创建静态变量/方法；原因我们知道要使用一个类的静态成员，
				 需要先把这个类加载到虚拟机中，而成员内部类是需要由外部类对象 
				 new 一个实例才可以使用，这就无法做到静态成员的要求
				 
	静态内部类：不持有外部类的引用
	局部内部类 ：
	匿名内部类：持有外部内部类的引用
	
2，类的加载过程
		   （连接过程:包含验证，准备，解析）
   加载 --> 验证-->准备-->解析 -->初始化-->使用-->卸载
   虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。
   创建类的实例
	1，访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，
	因为编译器把他们当作值(value)而不是域(field)来对待。
	如果你的代码中用到了常变量(constant variable)，
	编译器并不会生成字节码来从对象中载入域的值，
	而是直接把这个值插入到字节码中。这是一种很有用的优化，
	但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。
,   2，访问类的静态方法
	3，反射如(Class.forName("my.xyz.Test"))
,   4，当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化
	5，虚拟机启动时，定义了main()方法的那个类先初始化
	被动引用的例子
	1，子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化.
	2，通过数组定义来引用类，不会触发类的初始化
	3，访问类的常量，不会初始化类
	
3，final







4，hashmap 和hashtab 原理
   HashMap底层也是哈希数组+链表；通过key的hash值计算出index 将对象HashMapEntry存入HashMapEntry数组中
   其中HashMapEntry中next指的是计算等到相同的index值，然后这里采用链表将相同hash值的放在一个index
   HashSet<E> 底层封装了一个HashMap<E,HashSet<E>>
   HashTab:底层hash数组+链表，只是hashtable是线程安全的
   
   SparseArray是android里为<Interger,Object>这样的Hashmap而专门写的类,目的是提高内存效率，
   其核心是折半查找函数（binarySearch）
    
     
5,transient 
   实现了Serilizable 接口的对象，变量用transient修饰的不被序列化
6,数据结构：数组和链表是最基本的数据结构，其他都是这两个数据结构的演变
  数组：在内存是一块连续的内存
  链表：在每个元素包含数据域和指针域，通过指针域找到下个数据，在内存中不是连续的
7,java 运算符
  异或：如果相同则为0，不相同则为
  
  负数在计算机中的存储形式是其同值正数的补码
  正数的反码：原码各位取反
  补码：反码+1
  
8，java反射
   
9，LinkList ArrayList
   LinkList 底层是链表结构，查询慢，增删快，（适合做增删）Node(pre,next,element)
   ArrayList 底层是数组结构(维持一个数组对象)，查询快，增删慢（适合做查询操作）
10，TreeSet 和TreeMap Node(parent,left,right)
     底层都是二叉树结构，


11，java内存模型：
   原子性：不可被中断；eg,基本数据变量的读取和赋值
   可见性：volatile保证线程之间共享变量的可见性
   有序性：synchronized,lock,保证每个时刻只有一个线程执行同步代码
   
   volatile:加了这个关键字有两个含义：
   a,线程修改了变量的值时，变量的新值对其他线程是立即可见的；
   b,禁止使用指令重排序；
   c,只保证了可见性，但不保证原子性	 
   
12，thread
    sleep :释放cpu执行权，不释放锁
	wait:释放cpu执行权，释放锁；（和notify一起使用）；必需和同步代码块一起执行
	yield:释放cpu执行权，不释放锁
	如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中
	比如wait是object中的,sleep,yield是Thread中的
	
	线程池执行任务大致规则：
	首先线程池中的线程没有达到核心线程的数量，就创建线程
	其次如果达到核心线程的数量，则加入任务队列
	再次，如果队列都达到最大值，核心线程达到核心线程数，但是没有达到线程最大数，则创建非核心线程
	最后，上面都不满足了就拒绝执行此任务
	
	threadlocal :线程内部的数据存储类；当某些数据以线程为作用域并且不同线程有不同的数据副本，那么就可以
				考虑使用threadlocal;
				
	ThreadLocalMap:是ThreadLocal的内部类，是一个自定义
	
	Looper：每个线程中只能创建一个looper
	looper.prepared():是在创建一个当前线程的looper
	looper.loop():是获取当前线程的looper
	
	MessageQueue:
	
	
	锁：分为对象锁和类锁，ex:Test；Test.class(类锁)，对象锁（this）
	多线程场景下，当某一线程获得类锁(注意：不再是对象锁)，其它线程将被阻塞，将无法调用或访问该类的所有方法和域，包括静态方法和静态变量；
	对象锁和类锁不是一个锁
	
   
13 ,软引用：如果内存空间不足了，就回回收这些对象

    弱引用：不管当前内存空间足够与否，都会回收它的内存 （gc调用就会回收） 
	
	虚引用（PhantomReference）：在任何时候都可能被垃圾回收器回收 ；虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：
	虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，
	就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中
	
	强引用：抛出oom都不会回收
	
	
14 java参数传递 对象包括对象引用即地址和对象的内容
   基本数据类型：传递的是值的副本，方法中的值修改之后，原值不变；
   对象：传递的是地址的副本，如果方法中只是修改对象中的属性，这个原对象的属性变化；但是如果方法中
          对象重新创建，则原对象保持不变

	如果参数类型是原始类型，那么传过来的就是这个参数的一个副本，也就是这个原始参数的值，
	这个跟之前所谈的传值是一样的。如果在函数中改变了副本的值不会改变原始的值.
	
　　如果参数类型是引用类型，那么传过来的就是这个引用参数的副本，这个副本存放的是参数的地址。
	如果在函数中没有改变这个副本的地址，而是改变了地址中的值，那么在函数内的改变会影响到传入的参数。
	如果在函数中改变了副本的地址，如new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的地址，
	所以不会改变参数的值。
	
15,String
    StringBuilder  是非线程安全的
	SringBuffer是线程安全的
	String str = "abc"+"de";这行代码在内存中创建了3个字符串常量，一个StringBuilder对象，一个String对象
	Sring str2 = "abcde";
	str == str2 (false)
	str2 == str.intern()(true)
	str.equals(str2)(true)值相等
	String s1 = new String("kvill"); 这行代码创建了常量“kvill" 和一个String对象
	String.intern()；该方法获取字符串的常量

16设计模式
  内存设计模式：对象池模式和享元模式
   享元模式：为所有的对象只创建一个实例，实现内部状态的重用，减少复制它带来的消耗；
             （保证一个类型的对象只创建一个）
   六大原则：
   单一职责：就一个类而言，
  
17,泛型
   泛型，即“参数化类型”；？表示通配符，不需要定义；泛型T是需要定义的
   <? super B> 能对这个泛型做插入操作，而无法读
   <? extends B> 禁止做插入操作，只做读取
  
 18,java中classpath设置问题
    用法: javac <options> <source files>
     javac 类名的全路径+类名.java  (编译成class文件)
     eg:javac  D:\code\DevResCollect\libjava2\src\main\jav
    a\com\example\libjava2\AESUtils.java  :class生成和.java一个目录
      或者cd到类在的目录然后javac 类名.java

     java 包名+类名 （执行类的main函数）
     eg: java com.example.libjava2.AESUtils ,在包名的上一个目录
     ps:查找class文件路径是在当前目录+包名+class文件
     所以这个当前目录就是包名的上个目录，然后执行上面的指令。
  